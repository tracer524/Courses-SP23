def gcd(a, b):  
    while a != b:
        if a > b:
            a -= b
        else:
            b -= a
    return a

class Rational:
    def __init__(self, n=0, d=1):  
        a=gcd(n,d)
        n=n/a
        d=d/a
        if(d<0):
            n=-n
            d=-d
        _nu = n; _de = d
        self.__dict__['nu'] = _nu; self.__dict__['de'] = _de

    def __setattr__(self, name, value):
        raise TypeError('Error: Rational objects are immutable')

    def __str__(self): return '%d/%d' % (self.nu, self.de)

    def __add__(self, other):  
        a=self.de*other.de
        b=self.nu*other.de+self.de*other.nu
        return Rational(b,a)
    def __sub__(self, other):  
        a=self.de*other.de
        b=self.nu*other.de-self.de*other.nu
        return Rational(b,a)
    def __mul__(self, other):
        a=self.de*other*de
        b=self.nu*other.nu
        return Rational(b,a)
    def __truediv__(self, other):  
        a=self.de*other*nu
        b=self.nu*other.de
        return Rational(b,a)
    def __eq__(self, other):  
        if(self.de==other.de and self.nu==other.de): return("True")
        else: return("False") 
    def __ne__(self, other):  
        if(self.de==other.de and self.nu==other.de): return("False")
        else: return("True")
    def __gt__(self, other):  
        if(self.nu*other.de>self.de*self.nu):return("True")
        else: return("False")
    def __lt__(self, other):  
        if(self.nu*other.de<self.de*self.nu):return("True")
        else: return("False")
    def __ge__(self, other):  
        if(self.nu*other.de>=self.de*self.nu):return("True")
        else: return("False")
    def __le__(self, other):  
        if(self.nu*other.de<=self.de*self.nu):return("True")
        else: return("False")
def test():
    testsuite = [
        ('Rational(2, 3) + Rational(-70, 40)',
          Rational(-13, 12)),
        ('Rational(-20, 3) - Rational(120, 470)',
          Rational(-976,141)),
        ('Rational(-6, 19) * Rational(-114, 18)',
          Rational(2, 1)),
        ('Rational(-6, 19) / Rational(-114, -28)',
          Rational(-28,361)),

        ('Rational(-6, 19) == Rational(-14, 41)', False),
        ('Rational(-6, 19) != Rational(-14, 41)', True),
        ('Rational(6, -19) > Rational(14, -41)', True),
        ('Rational(-6, 19) < Rational(-14, 41)', False),
        ('Rational(-6, 19) >= Rational(-14, 41)', True),
        ('Rational(6, -19) <= Rational(14, -41)', False),
        ('Rational(-15, 8) == Rational(120, -64)', True),
    ]
    for t in testsuite:
        try:
            result = eval(t[0])
        except:
            print('Error in evaluating ' + t[0]); continue

        if result != t[1]:
            print('Error:  %s != %s' % (t[0], t[1]))

if __name__ == '__main__':
    test()



























import math

class Integrator:
    def __init__(self, a, b, n):
        self.a, self.b, self.n = a, b, n
        self.points, self.weights = self.compute_points()

    def compute_points(self):
        raise NotImplementedError(self.__class__.__name__)

    def integrate(self, f):
        a=0
        for i,j in zip(self.points,self.weights):
            a=a+j*f(i)
        return a
class Trapezoidal(Integrator):
    def compute_points(self):
        a,b,n=self.a,self.b,self.n
        self.points=[]
        self.weights=[]
        h=(b-a)/n
        for i in range(n+1):
            self.points[i]=a+i*h
            if(i==0 or i==n):self.weights[i]=h/2
            else: self.weights[i]=h
        return(self.points,self.weights)    
            
class Simpson(Integrator):
    def compute_points(self):
        a,b,n=self.a,self.b,self.n
        self.points=[]
        self.weights=[]
        if(n%2==1):n=n+1
        h=(b-a)/n
        for i in range(n+1):
            self.points[i]=a+i*h
            if(i==0 or i==n):self.weights[i]=h/2
            elif(i%2==0): self.weights[i]=h*2/3
            else: self.weights[i]=h*4/3
        return(self.points,self.weights)    

class GaussLegendre(Integrator):
    def compute_points(self):
        a,b,n=self.a,self.b,self.n
        self.points=[]
        self.weights=[]
        if(n%2==0):n=n+1
        h=(b-a)/n
        for i in range(n+1):
            if(i%2==0):self.points[i]=a+(i+1)/2*h-(3^0.5)*h
            else:self.points[i]=a+i/2*h+(3^0.5)*h
            self.weights[i]=h/2
        return(self.points,self.weights)    

        
def test():
    def f(x): return (x * math.cos(x) + math.sin(x)) * \
                      math.exp(x * math.sin(x))
    def F(x): return math.exp(x * math.sin(x))

    a = 2; b = 3; n = 200
    I_exact = F(b) - F(a)
    tol = 1E-3

    methods = [Trapezoidal, Simpson, GaussLegendre]
    for method in methods:
        integrator = method(a, b, n)
        I = integrator.integrate(f)
        rel_err = abs((I_exact - I) / I_exact)
        print('%s: %g' % (method.__name__, rel_err))
        if rel_err > tol:
            print('Error in %s' % method.__name__)

if __name__ == '__main__':
    test()
