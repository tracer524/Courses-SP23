1.def three_sum(nums):    nums.sort()  # O(nlog n)    n = len(nums)    result = []    for i in range(n - 2):  # O(n^2)        if i > 0 and nums[i] == nums[i - 1]:            continue        target = -nums[i]        left = i + 1        right = n - 1        while left < right:            if nums[left] + nums[right] == target:                result.append([nums[i], nums[left], nums[right]])                while left < right and nums[left] == nums[left + 1]:                    left += 1                while left < right and nums[right] == nums[right - 1]:                    right -= 1                left += 1                right -= 1            elif nums[left] + nums[right] < target:                left += 1            else:                right -= 1    return result2.﻿import randomimport timeitdef generate_random_list(length):    return [random.randint(0, 1000) for _ in range(length)]def insertion_sort(arr):    for i in range(1, len(arr)):        key = arr[i]        j = i - 1        while j >= 0 and arr[j] > key:            arr[j + 1] = arr[j]            j -= 1        arr[j + 1] = keydef merge_sort(arr):    if len(arr) <= 1:        return arr    mid = len(arr) // 2    left = merge_sort(arr[:mid])    right = merge_sort(arr[mid:])    return merge(left, right)def merge(left, right):    merged = []    i = j = 0    while i < len(left) and j < len(right):        if left[i] <= right[j]:            merged.append(left[i])            i += 1        else:            merged.append(right[j])            j += 1    merged.extend(left[i:])    merged.extend(right[j:])    return mergeddef quick_sort(arr):    if len(arr) <= 1:        return arr    pivot = arr[len(arr) // 2]    left = [x for x in arr if x < pivot]    middle = [x for x in arr if x == pivot]    right = [x for x in arr if x > pivot]    return quick_sort(left) + middle + quick_sort(right)lengths = range(100, 1001, 100)num_runs = 10for length in lengths:    print(f"Length: {length}")    avg_insertion_time = 0    avg_merge_time = 0    avg_quick_time = 0    for _ in range(num_runs):        random_list = generate_random_list(length)        insertion_time = timeit.timeit(lambda: insertion_sort(random_list.copy()), number=1)        avg_insertion_time += insertion_time        merge_time = timeit.timeit(lambda: merge_sort(random_list.copy()), number=1)        avg_merge_time += merge_time        quick_time = timeit.timeit(lambda: quick_sort(random_list.copy()), number=1)        avg_quick_time += quick_time    avg_insertion_time /= num_runs    avg_merge_time /= num_runs    avg_quick_time /= num_runs    print(f"Avg Insertion Sort Time: {avg_insertion_time:.6f} seconds")    print(f"Avg Merge Sort Time: {avg_merge_time:.6f} seconds")    print(f"Avg Quick Sort Time: {avg_quick_time:.6f} seconds")    print()out:﻿Length: 100Avg Insertion Sort Time: 0.000512 secondsAvg Merge Sort Time: 0.000373 secondsAvg Quick Sort Time: 0.000235 secondsLength: 200Avg Insertion Sort Time: 0.001488 secondsAvg Merge Sort Time: 0.000601 secondsAvg Quick Sort Time: 0.000400 secondsLength: 300Avg Insertion Sort Time: 0.002581 secondsAvg Merge Sort Time: 0.000732 secondsAvg Quick Sort Time: 0.000449 secondsLength: 400Avg Insertion Sort Time: 0.004360 secondsAvg Merge Sort Time: 0.000956 secondsAvg Quick Sort Time: 0.000611 secondsLength: 500Avg Insertion Sort Time: 0.007111 secondsAvg Merge Sort Time: 0.001207 secondsAvg Quick Sort Time: 0.000714 secondsLength: 600Avg Insertion Sort Time: 0.010767 secondsAvg Merge Sort Time: 0.001606 secondsAvg Quick Sort Time: 0.000919 secondsLength: 700Avg Insertion Sort Time: 0.015282 secondsAvg Merge Sort Time: 0.001956 secondsAvg Quick Sort Time: 0.001111 secondsLength: 800Avg Insertion Sort Time: 0.019149 secondsAvg Merge Sort Time: 0.002100 secondsAvg Quick Sort Time: 0.001199 secondsLength: 900Avg Insertion Sort Time: 0.024423 secondsAvg Merge Sort Time: 0.002424 secondsAvg Quick Sort Time: 0.001342 secondsLength: 1000Avg Insertion Sort Time: 0.030516 secondsAvg Merge Sort Time: 0.002689 secondsAvg Quick Sort Time: 0.001472 seconds3.﻿import timeitdef merge_ordered_lists(s1, s2):    t = []    i = j = 0    while i < len(s1) and j < len(s2):        if s1[i] < s2[j]:            t.append(s1[i])            i += 1        else:            t.append(s2[j])            j += 1    t += s1[i:]    t += s2[j:]    return tdef merge_sort(s):    if len(s) <= 1:        return s    mid = len(s) // 2    left = merge_sort(s[:mid])    right = merge_sort(s[mid:])    return merge_ordered_lists(left, right)s = [21, 73, 6, 67, 99, 60, 77, 5, 51, 32]# Measure merge_ordered_lists functionmerge_ordered_lists_time = timeit.timeit(lambda: merge_ordered_lists([21, 73], [6, 67]), number=1)print(f"merge_ordered_lists time: {merge_ordered_lists_time:.6f} seconds")# Measure merge_sort functionmerge_sort_time = timeit.timeit(lambda: merge_sort(s), number=1)print(f"merge_sort time: {merge_sort_time:.6f} seconds")Out:﻿merge_ordered_lists time: 0.000006 secondsmerge_sort time: 0.000017 seconds