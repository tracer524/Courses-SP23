1.﻿import numpy as npimport matplotlib.pyplot as pltfrom scipy import integratedef function(x):    return (x * np.cos(x) + np.sin(x)) * np.exp(x * np.sin(x))def composite_trapezoidal(f, a, b, n):    h = (b - a) / n    x = np.linspace(a, b, n + 1)    y = f(x)    integral = h * (np.sum(y) - 0.5 * (y[0] + y[-1]))    return integraldef composite_simpson(f, a, b, n):    h = (b - a) / n    x = np.linspace(a, b, n + 1)    y = f(x)    integral = (h / 3) * (np.sum(y[0:-1:2]) + 4 * np.sum(y[1::2]) + y[-1])    return integraldef composite_gauss_legendre(f, a, b, n):    x, w = np.polynomial.legendre.leggauss(n)    x_scaled = 0.5 * (b - a) * x + 0.5 * (b + a)    y = f(x_scaled)    integral = 0.5 * (b - a) * np.dot(w, y)    return integraldef calculate_relative_error(integral_approx, integral_exact):    return np.abs(integral_approx - integral_exact) / np.abs(integral_exact)def plot_error_vs_n(n_values, relative_errors_trapezoidal, relative_errors_simpson, relative_errors_gauss):    plt.plot(n_values, relative_errors_trapezoidal, marker='o', label='Composite Trapezoidal')    plt.plot(n_values, relative_errors_simpson, marker='o', label='Composite Simpson')    plt.plot(n_values, relative_errors_gauss, marker='o', label='Composite Gauss-Legendre')    plt.xlabel('n')    plt.ylabel('Relative Error')    plt.xscale('log')    plt.yscale('log')    plt.title('Relative Error vs n for Composite Integration Methods')    plt.legend()    plt.show()def main():    a = 0  # 积分下限    b = 1  # 积分上限    n_values = [10, 100, 1000, 10000]  # 选取的n值    relative_errors_trapezoidal = []    relative_errors_simpson = []    relative_errors_gauss = []    integral_exact, _ = integrate.quad(function, a, b)  # 计算精确积分值    for n in n_values:        integral_trapezoidal = composite_trapezoidal(function, a, b, n)        integral_simpson = composite_simpson(function, a, b, n)        integral_gauss = composite_gauss_legendre(function, a, b, n)        relative_error_trapezoidal = calculate_relative_error(integral_trapezoidal, integral_exact)        relative_error_simpson = calculate_relative_error(integral_simpson, integral_exact)        relative_error_gauss = calculate_relative_error(integral_gauss, integral_exact)        relative_errors_trapezoidal.append(relative_error_trapezoidal)        relative_errors_simpson.append(relative_error_simpson)        relative_errors_gauss.append(relative_error_gauss)    plot_error_vs_n(n_values, relative_errors_trapezoidal, relative_errors_simpson, relative_errors_gauss)if __name__ == '__main__':    main()2.import timeimport randomimport matplotlib.pyplot as pltdef insertion_sort(arr):    for i in range(1, len(arr)):        key = arr[i]        j = i - 1        while j >= 0 and arr[j] > key:            arr[j + 1] = arr[j]            j -= 1        arr[j + 1] = keydef merge_sort(arr):    if len(arr) > 1:        mid = len(arr) // 2        left_half = arr[:mid]        right_half = arr[mid:]        merge_sort(left_half)        merge_sort(right_half)        i = j = k = 0        while i < len(left_half) and j < len(right_half):            if left_half[i] < right_half[j]:                arr[k] = left_half[i]                i += 1            else:                arr[k] = right_half[j]                j += 1            k += 1        while i < len(left_half):            arr[k] = left_half[i]            i += 1            k += 1        while j < len(right_half):            arr[k] = right_half[j]            j += 1            k += 1def quick_sort(arr):    if len(arr) <= 1:        return arr    pivot = arr[len(arr) // 2]    left = [x for x in arr if x < pivot]    middle = [x for x in arr if x == pivot]    right = [x for x in arr if x > pivot]    return quick_sort(left) + middle + quick_sort(right)def measure_time(algorithm, data_sizes):    time_taken = []    for size in data_sizes:        data = random.sample(range(size), size)        start_time = time.time()        algorithm(data)        end_time = time.time()        time_taken.append(end_time - start_time)    return time_takendef plot_graph(data_sizes, time_taken):    plt.plot(data_sizes, time_taken[0], label='Insertion Sort')    plt.plot(data_sizes, time_taken[1], label='Merge Sort')    plt.plot(data_sizes, time_taken[2], label='Quick Sort')    plt.xlabel('List Length')    plt.ylabel('Time Taken (seconds)')    plt.title('Sorting Algorithms Performance')    plt.legend()    plt.show()def main():    data_sizes = [1000, 2000, 3000, 4000, 5000]      algorithms = [insertion_sort, merge_sort, quick_sort]    time_taken = []    for algorithm in algorithms:        time_taken.append(measure_time(algorithm, data_sizes))    plot_graph(data_sizes, time_taken)if __name__ == '__main__':    main()3.﻿import numpy as npimport matplotlib.pyplot as pltdef z_function(x, y):    return (3 * (x**3) - 2 * x + 4 * (x**2) * y + 2 * (y**2)) * np.exp(-1 * (x**2) - (y**2))x = np.linspace(-2, 2, 100)y = np.linspace(-2, 2, 100)X, Y = np.meshgrid(x, y)Z = z_function(X, Y)fig = plt.figure(figsize=(12, 10))ax1 = fig.add_subplot(2, 2, 1, projection='3d')ax1.plot_surface(X, Y, Z, cmap='viridis')ax1.set_title('3D Surface Plot')ax2 = fig.add_subplot(2, 2, 2)ax2.contour(X, Y, Z, cmap='viridis')ax2.set_title('Contour Plot (Fixed x)')ax2.set_xlabel('y')ax2.set_ylabel('z')ax3 = fig.add_subplot(2, 2, 3)ax3.contour(X, Y, Z, cmap='viridis')ax3.set_title('Contour Plot (Fixed y)')ax3.set_xlabel('x')ax3.set_ylabel('z')ax4 = fig.add_subplot(2, 2, 4)ax4.contour(X, Y, Z, cmap='viridis')ax4.set_title('Contour Plot (Fixed z)')ax4.set_xlabel('x')ax4.set_ylabel('y')fig.tight_layout()plt.show()3.